---
layout: post
title: "Lesson 04: Subset and Manipulate Time Series Data with dplyr"
date:   2015-10-21
authors: [Megan A. Jones, Marisa Guarinello, Courtney Soderberg]
contributors: [Leah A. Wasser, Michael Patterson]
dateCreated: 2015-10-22
lastModified: `r format(Sys.time(), "%Y-%m-%d")`
packagesLibraries: [ggplot2, dplyr, lubridate]
tags: [spatio-temporal, time-series, phenology]
mainTag: time-series
packagesLibraries: [lubridate, ggplot2, dplyr]
category: 
description: "This lesson teaches how to conduct basic data manipulation using
`dplyr` functions including `group_by`, `summarize`and `mutate`. The use of pipes
is taught and used throughout the lesson. Finally the new data frames created in
the previous manipulations will be plotted using `ggplot()`. "
code1: TS04-Dplyr-And-Time-Series-In-R.R
image:
  feature: NEONCarpentryHeader_2.png
  credit: A collaboration between the National Ecological Observatory Network (NEON) and Data Carpentry
  creditlink: http://www.neoninc.org
permalink: /R/Time-Series-Subset-dplyr
comments: false
---

{% include _toc.html %}


##About
In this lesson, we will use the `group_by`, `summarize`and `mutate` functions in the 
`dplyr` package to efficiently manipulate atmospheric data collected at the NEON
Harvard Forest Field Site. We will use pipes to efficiently perform multiple
tasks within a single chunk of code.

**R Skill Level:** Intermediate - you've got the basics of `R` down.


<div id="objectives" markdown="1">

### Goals / Objectives
After completing this lesson, you will:

 * Know several ways to manipulate data using functions in the `dplyr` package
 in `R`.
 * Be able to use `group-by()`, `summarize()`, and `mutate()` functions. 
 * Write and understand `R` code with pipes for cleaner, efficient coding.
 * Use the `year()` function from the `lubridate` package to extract year from a
 date-time class variable. 

##Things Youâ€™ll Need To Complete This Lesson
To complete this lesson: you will need the most current version of R, and 
preferably RStudio, loaded on your computer.

###Install R Packages
* **lubridate:** `install.packages("lubridate")`
* **dplyr:** `install.packages("dplyr")`
* **ggplot2:** `install.packages("ggplot2")`

* [More on Packages in R - Adapted from Software Carpentry.]({{site.baseurl}}R/Packages-In-R/)

##Data to Download
{% include/dataSubsets/_data_Met-Time-Series.html %}

****

{% include/_greyBox-wd-rscript.html %}

**Tabular Time Series Lesson Series:** This lesson is part of a lesson series on 
[tabular time series data in R ]({{ site.baseurl }}self-paced-tutorials/tabular-time-series). 
It is also part of a larger 
[spatio-temporal Data Carpentry workshop ]({{ site.baseurl }}self-paced-tutorials/spatio-temporal-workshop)
that includes working with
[raster data in R ]({{ site.baseurl }}self-paced-tutorials/spatial-raster-series) 
and  
[vector data in R ]({{ site.baseurl }}self-paced-tutorials/spatial-vector-series).

****

## Additional Resources

* NEON Data Skills on <a href="http://neondataskills.org/R/GREPL-Filter-Piping-in-DPLYR-Using-R/" target="_blank"> spatial data and piping with dplyr</a> or 
* Data Carpentry on <a href="http://www.datacarpentry.org/R-ecology/04-dplyr.html" target="_blank">Aggregating and Analyzing Data with dplyr</a> 
* <a href="https://cran.r-project.org/web/packages/dplyr/dplyr.pdf" target="_blank"> dplyr package description</a>.
* <a href="http://blog.rstudio.org/2014/01/17/introducing-dplyr/" target="_blank">RStudio Introduction to dplyr</a>

</div>

#Introduction to dplyr
The `dplyr` package simplifies and increases efficiency of complicated yet commonly 
performed data "wrangling" (manipulation / processing) tasks. It uses the `data_frame` 
object as both an input and an output.

##Load the Data
We will need the `lubridate` and the `dplyr` packages to complete this lesson.

We will also use the 15-minute average atmospheric data subsetted to 2009-2011 
for the NEON Harvard Forest Field Site. This subset was created in the [Subsetting Time Series Data lesson]({{site.baseurl}}/R/Subset-Data-and-No-Data-Values/ "2009-2011 HarMet Data Subset"). 

If this object isn't already created, please load the `.csv` version: 
`NEON-DS-Met-Time-Series/HARV/FisherTower-Met/Met_HARV_15min_2009_2011.csv`. Be sure to convert the 
date-time column to a POSIXct class after you load the `.csv`.  

```{r load-data}

#it's good coding practice to load packages at the top of a script

#work with dates
library(lubridate) 
#data manipulation (filter, summarize, mutate)
library(dplyr) 
library(ggplot2)

#set working directory to ensure R can find the file we wish to import
#setwd("working-dir-path-here")

#15-min Harvard Forest met data, 2009-2011
harMet15.09.11<- read.csv(file="NEON-DS-Met-Time-Series/HARV/FisherTower-Met/Met_HARV_15min_2009_2011.csv",
                          stringsAsFactors = FALSE)
#convert datetime to POSIXct
harMet15.09.11$datetime<-as.POSIXct(harMet15.09.11$datetime,
                    format = "%Y-%m-%d %H:%M",
                    tz = "America/New_York")
```

##Explore Our Data

Remember that we are interested in the drivers of phenology including - 
air temperature, precipitation, and PAR (photosynthetic active radiation - or
the amount of visible light). Using the 15-minute averaged data, we could easily
plot each of these variables.  

```{r 15-min-plots, echo=FALSE}
#this library is used to quickly tile several plots
#next to each other
library(gridExtra)
library(scales)

a <- ggplot(harMet15.09.11, aes(x=datetime, y=airt)) + 
           geom_point(na.rm=TRUE, size = .1) +
           scale_x_datetime(breaks=date_breaks("1 year")) +
           ggtitle("Air Temp \n NEON Harvard Forest Field Site") +
           xlab("Date") + 
           ylab("Air Temperature, Celcius")

b <- ggplot(harMet15.09.11, aes(x=datetime, y=prec)) +
          geom_point(na.rm=TRUE, size = .1) +
          scale_x_datetime(breaks=date_breaks("1 year")) +
           ggtitle("Precipitation \n NEON Harvard Forest Field Site")+
           xlab("Date") + ylab("Daily Total Precip., mm")

c <- ggplot(harMet15.09.11, aes(x=datetime, y=parr))+
          geom_point(na.rm=TRUE, size = .1) +
           scale_x_datetime(breaks=date_breaks("1 year")) +
           ggtitle("Air Temp \n NEON Harvard Forest Field Site") +
           xlab("Date") + ylab("Total PAR-Daily Mean")

grid.arrange(a,b,c, ncol=2)


```

However, summarizing the data at a coarser scale (e.g., daily, weekly, by season, 
or by year) may be easier to visually interpret during initial stages of
data exploration. 

###Extract Year from a Date-Time Column

To summarize by year efficiently, it is helpful to have a year column that we
can use to `group` by. We can use the `lubridate` function `year()` to extract
the year only from a `date-time` class `R` column. 

```{r dplyr-lubridate-2}
harMet15.09.11$year <- year(harMet15.09.11$datetime)
```

Using `names()` we can see that we now have a `year` column in our `data.frame`.

```{r dplyr-lubridate-3}
#check to make sure it worked
names(harMet15.09.11)
str(harMet15.09.11$year)
```

Now that we have added a year column to our data.frame, we can use `dplyr` to 
summarize our data.


#Manipulate Data using dplyr
Let's start by extracting a yearly air temperature value for the Harvard Forest
data. To calculate a yearly average, we need to:

1. Group our data by year
2. Calculate the mean precipitation value for each group

We will use `dplyr` functions `group_by` and `summarize` to perform these steps.

```{r group-by-dplyr }

#Create a group_by object using the year column 
HARV.grp.year <- group_by(harMet15.09.11, #data_frame object
         year) #column name to group by

#view class of the grouped object
class(HARV.grp.year)
```

The `group_by` function creates a "grouped" object. We can then use this
grouped object to quickly calculate summary statistics by group - in this case, year.
For example, we can count how many measurements were made each year using the `tally()`
function. We can then use the `summarize` function to calculate the mean
air temperature value each year.

```{r tally-by-year }
#how many measurements were made each year?
tally(HARV.grp.year)

#what is the mean airt value per year?
summarize(HARV.grp.year, 
          mean(airt)) #calculate the annual mean of airt

```

Why did this return a `NA` value for years 2009 and 2010? We know there
are some values for both years. Let's check our
data for `NoData` values.

```{r check-data }
#are there NoData values?
sum(is.na(HARV.grp.year$airt))

#where are the no data values
#just view the first 6 columns of data
HARV.grp.year[is.na(HARV.grp.year$airt),1:6]

```

It appears as if there are two `NoData` values (in 2009 and 2010) that are causing 
`R` to return a `NA` for the mean for those years. As we learned previously, 
we can use `na.rm` to tell `R` to ignore those values and calculate the final mean
value.

``` {r calculate-mean-value }
#calculate mean but remove NA values
summarize(HARV.grp.year, 
          mean(airt, na.rm = TRUE))

```

Great! We've now used the `group_by` function to create groups for each year 
of our data. We then calculated a summary mean value per year using `summarize`.

##dplyr Pipes 
The above steps utilized several steps of `R` code and created 1 `R` object - 
`HARV.grp.year`. We can combine these steps using `pipes` in the `dplyr` package.
`Pipes` allow us to create a string of functions where the output of each step
is fed directly into the next step using the syntax: `%>%`. This means we don't 
need to name the output of each intermediate step.

A few notes about piping syntax:

1. A pipe begins with the object name that we will be manipulating, in our case `harMet15.09.11`
2. it then links that object with first manipulation step using `%>%`
3. finally, the first function is called, in our case `group_by(year)`. Note that 
because we specified the object name in step one above, we can just use the column
name

so, we have: `harMet15.09.11 %>% group_by(year) `

4. We can then add an additional function (or more functions!) to our pipe. For
example, we can tell `R` to `tally` or count the number of measurements per year.

`harMet15.09.11 %>% group_by(year) %>% tally()`

Let's try it!


```{r using-pipes }

#how many measurements were made a year?
harMet15.09.11 %>% 
  group_by(year) %>%  #group by year
  tally() #count measurements per year

```

Piping allows us to efficiently perform operations on our `data.frame` in that:

1. It allows us to condense our code, without naming intermediate steps
2. The dplyr package is optimized to ensure fast processing!

We can use pipes to summarize data by year too:

```{r summ-data }
#what was the annual air temperature average 
year.sum <- harMet15.09.11 %>% 
  group_by(year) %>%  #group by year
  summarize(mean(airt, na.rm=TRUE))

#what is the class of the output?
year.sum
#view structure of output
str(year.sum)
```


<div id="challenge" markdown="1" >
##Challenge

Using the piping syntax that we just learned, create a `data_frame` called jday.avg
that contains the average `airt` per julian day (`harMet15.09.11$jd`). Plot
the output using `qplot`.

</div>


```{r pipe-demo, echo = FALSE}
jday.avg <- harMet15.09.11 %>%      #Within the harMet15.09.11 data
            group_by(jd) %>%      #group the data by the Julian day
            summarize((mean(airt,na.rm=TRUE)))  #and summarize temp per julian day
names(jday.avg) <- c("jday","meanAirTemp")

qplot(jday.avg$jday,jday.avg$meanAirTemp,
        main="2009-2011 Average Air Temperature by Julian Day\n NEON Harvard Forest Field Site",
      xlab="Julian Day", ylab="Temp (C)")

```



<i class="fa fa-star"></i> **Data Tip:**  Older `dplyr` versions used the `%.%` syntax
to designate a pipe. Pipes are occasionally sometimes referred to as chains. 
{: .notice }

##Other dplyr functions

`dplyr` works based on a series of *verb* functions that allow us to 
manipulate the data in different ways: 

 * `filter()` & `slice()`: filter rows based on values in specified columns
 * `group-by()`: group all data by a column
 * `arrange()`: sort data by values in specified columns 
 * `select()` & `rename()`: view and work with data from only specified columns
 * `distinct()`: view and work with only unique values from specified columns
 * `mutate()` & `transmute()`: add new data to a data frame
 * `summarise()`: calculate the specified summary statistics
 * `sample_n()` & `sample_frac()`: return a random sample of rows
 
(List modified from the CRAN `dplyr` <a href="https://cran.r-project.org/web/packages/dplyr/dplyr.pdf" target="_blank"> package description</a>. )

The syntax for all `dplyr` functions is similar: 

 * the first argument is the target `data.frame`, 
 * the subsequent arguments dictate what to do with that `data.frame` and 
 * the output is a new data frame. 


##Group by a Variable (or Two)

Our goal for this lesson is to view drivers of annual phenology 
patterns. Specifically, we want to explore daily average temperature throughout 
the year. This means we need to calculate average temperature, for each day, across 
three years. To do this we can use the `group_by()` function as we did earlier.
However this time, we can group by two variables: year and Julian Day (jd) as follows:

`group_by(year, jd)`

Let's begin by counting or `tally`ing the total measurements per
Julian day (or year day) using the `group_by()` function and pipes. 

```{r dplyr-group}
harMet15.09.11 %>%      #use the harMet15.09.11 data_frame
  group_by(year, jd) %>%   #group data by Year & Julian day
  tally()               # tally (count) observations per jd / year
```

The output shows we have 96 values for each day. Is that what we expect? 

``` {r simple-math}
24*4  #  24 hours/day * 4 15-min data points/hour
```


<i class="fa fa-star"></i> **Data Tip:**  If Julian days weren't already in our 
data we could use the `yday()` function <a href="http://www.inside-r.org/packages/cran/lubridate/docs/yday"/>
from the `lubridate` package to create a new column containing julian day values. 
[More Here]({{site.baseurl}}/R/julian-day-conversion/ "Julian Day Conversion"). 
{: .notice }

###Summarize by Group

We can use `summarize()` function to calculate a summary output value for each
"group" - in this case Julian day per year. Let's calculate the mean air temperature 
for each Julian day per year. Note that we are still using `na.rm=TRUE` to tell
`R` to skip `NA` values.


```{r dplyr-summarize}
harMet15.09.11 %>%
  group_by(year, jd) %>%
  summarize(mean_airt = mean(airt, na.rm = TRUE))  
```

<div id="challenge" markdown="1">
##Challenge

We can use `sum` to calculate the total rather than mean value for each Julian
Day. Using this information, do the following:

1. Calculate total `prec` for each Julian Day over the 3 years - name your
data.frame `total.prec`. 
2. Create a plot of Daily Total Precipitation for 2009-2011. 
3. Add a title and x and y axis labels.
4. If you use `qplot` to create your plot, use `colour=as.factor(total.prec$year)`
to color the data points by year.

</div>

```{r challenge-answer, echo=FALSE }

total.prec <- harMet15.09.11 %>%
  group_by(year, jd) %>%
  summarize(sum_prec = sum(prec, na.rm = TRUE)) 


qplot(total.prec$jd, total.prec$sum_prec,
      main="Total Precipitation",
      xlab="Julian Day", ylab="Precip (mm)", 
      colour=as.factor(total.prec$year))

```


###Mutate - Add Data.Frame Columns 2 dplyr Output

We can use the `mutate()` function of `dplyr` to add additional columns of information
to a data.frame. For instance, we added the year column independently
at the very beginning of the lesson. However, we can add the year using a `dplyr` 
pipe that also summarizes our data. To do this, we would use the syntax:

`mutate(year2 = year(datetime))`

year2 is the name of the column that will be added to the output `dplyr` data_frame.

```{r dplyr-mutate}
harMet15.09.11 %>%
  mutate(year2 = year(datetime)) %>%
  group_by(year2, jd) %>%
  summarize(mean_airt = mean(airt, na.rm = TRUE))

```


<i class="fa fa-star"></i> **Data Tip:** The `mutate` function is similar to
`transform()` in base `R`. However,`mutate()` allows us to create and 
immediately use the variable (`year2`).
{: .notice }

##Save dplyr OUTPUT as Data.Frame

We can save output from a `dplyr` pipe, as a new `R` object to use for quick plotting. 

```{r dplyr-create-data-frame}
harTemp.daily.09.11<-harMet15.09.11 %>%
                    mutate(year2 = year(datetime)) %>%
                    group_by(year2, jd) %>%
                    summarize(mean_airt = mean(airt, na.rm = TRUE))

head(harTemp.daily.09.11)
```

###Add Date-Time To dplyr Output

In the challenge above, we created a plot of daily precipitation data using qplot. 
However, the x-axis ranged from 0-366 (Julian Days for the year). It would have 
been easier to create a meaningful plot across all three years if we had a 
continuous date variable in our data_frame representing the year and date for 
each summary value. 

We can add the the `datetime` column value to our `data_frame` by adding an
additional argument to the `summarize()` function. In this case, we will add the
`first` datetime value that `R` encounters when summarizing data by group as follows:

`datetime = first(datetime)`

Your new summarize statement in our pipe will look like this:

`summarize(mean_airt = mean(airt, na.rm = TRUE), datetime = first(datetime))`

Let's try it!

```{r dplyr-dataframe}
harTemp.daily.09.11 <- harMet15.09.11 %>%
  mutate(year3 = year(datetime)) %>%
  group_by(year3, jd) %>%
  summarize(mean_airt = mean(airt, na.rm = TRUE), datetime = first(datetime))

str(harTemp.daily.09.11)

head(harTemp.daily.09.11)
```

<div id="challenge" markdown="1">

##Challenge: Applying dplyr Skills

1. Plot daily total precipitation from 2009-2011 as we did in the previous challenge.
However this time, use the new syntax that you learned (mutate and summarize to 
add a datetime column to your output data_frame).
2. Create a data.frame of the average MONTHLY air temperature for 2009-2011.
Name the new data frame "HarTemp.monthly.09.11". Plot your output.

</div>

``` {r challenge-code-dplyr, include=TRUE, echo=FALSE}
###########
#p1
total.prec2 <- harMet15.09.11 %>%
  group_by(year, jd) %>%
  summarize(sum_prec = sum(prec, na.rm = TRUE), datetime = first(datetime)) 


qplot(total.prec2$datetime, total.prec$sum_prec,
      main="Total Daily Precipitation 2009-2011\nNEON Harvard Forest Field Site",
      xlab="Date (Daily Values)", ylab=="Precip (mm)")
#####################
#p2
harTemp.monthly.09.11 <- harMet15.09.11 %>%
  mutate(month = month(datetime), year= year(datetime)) %>%
  group_by(month, year) %>%
  summarize(mean_airt = mean(airt, na.rm = TRUE), datetime = first(datetime))

qplot(harTemp.monthly.09.11$datetime, harTemp.monthly.09.11$mean_airt,
      main="Monthly Mean Air Temperature 2009-2011\nNEON Harvard Forest Field Site",
      xlab="Date (Month)", ylab="Air Temp (C)")

#str(harTemp.monthly.09.11)
```

