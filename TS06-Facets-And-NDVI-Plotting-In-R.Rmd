---
layout: post
title: "Lesson 06: Plot using Facets and Plot Time Series with NDVI data"
date:   2015-10-19
authors: [Megan A. Jones, Marisa Guarinello, Courtney Soderberg]
contributors: [Leah Wasser]
dateCreated: 2015-10-22
lastModified: `r format(Sys.time(), "%Y-%m-%d")`
category:  
tags: [spatio-temporal, time-series, phenology]
mainTag: time-series
description: "This lesson teaches how to plot subsetted time series data using
the `facets()` function (e.g., plot by season) and to plot time series data with
NDVI."
code1: TS06-Facets-And-NDVI-Plotting-In-R.R
image:
  feature: NEONCarpentryHeader_2.png
  credit: A collaboration between the National Ecological Observatory Network (NEON) and Data Carpentry
  creditlink: http://www.neoninc.org
permalink: /R/Time-Series-Plot-Facets-NDVI
comments: false
---

{% include _toc.html %}

##About
This lesson teaches how to plot subsetted time series data using
the `facets()` function (e.g., plot by season) and to plot time series data with
NDVI.

**R Skill Level:** Intermediate - you've got the basics of `R` down.

<div id="objectives" markdown="1">

###Goals / Objectives
After completing this activity, you will:

 * Know how to use `facets()` in the ggplot2 package.
 * Be able to combine different types of data into one plot.

**To complete this lesson:** you will need the most current version of R, and 
preferably RStudio, loaded on your computer.

####R Libraries to Install
* **ggplot:** `install.packages("ggplot2")`
* **scales:** `install.packages("scales")`
* **gridExtra:** `install.packages("gridExtra")`
* **grid:** `install.packages("grid")`
* **dplyr:** `install.packages("dplyr")`
* **reshape2:** `install.packages("reshape2")`

####Data to Download
<a href="https://ndownloader.figshare.com/files/3579861" class="btn btn-success"> Download Atmospheric Data</a>

The data used in this lesson were collected at Harvard Forest which is
an National Ecological Observatory Network  
<a href="http://www.neoninc.org/science-design/field-sites/harvard-forest" target="_blank"> field site</a>. 
These data are proxy data for what will be available for 30 years
on the [NEON data portal](http://data.neoninc.org/ "NEON data")
for both Harvard Forest and other field sites located across the United States.

**Set Working Directory:** This lessons assumes that you have set your working 
directory to the location of the downloaded and unzipped data subset. [An overview
of setting the working directory in `R` can be found here.]({{site.baseurl}}/R/Set-Working-Directory "R Working Directory Lesson") 
lesson prior to beginning this lesson.

**Challenge Code:** NEON Data lesson often contain challenges that reinforce 
learned skills. If available, the code for challenge solutions is found in a 
downloadable `R` script available on the footer of each lesson page.

###Additional Resources

####Skills Needed
This lessons assumes familiarity with both the `dplyr` package and `ggplot()` in
the `ggplot2` package.  If you are not comfortable with either of these we
recommend starting with the [Subset & Manipulate Time Series Data with `dplyr` lesson]({{site.baseurl}}/R/Time-Series-Subset-dplyr/ "Learn dplyr") 
and the [Plotting Time Series with ggplot in R lesson]({{site.baseurl}}/R/Time-Series-Plot-ggplot/ "Learn ggplot")  
respectively, to gain familiarity.


</div>

#Plotting Subsetted Data Using Facets
 
In this lesson we will learn how to create a panel of indivual plots - known as
facets in `ggplot2`. Each plot represents a particular `data_frame` time-series 
subset - for example year or season.

###Load the Data
We will use the daily micro-meteorology data for 2009-2011 from the Harvard
Forest. If you do not have this data loaded into an `R` `data_frame`, please 
load them, and convert date-time columns to a date-time class now.

```{r load-data}
#Remember it is good coding technique to add additional libraries to the top of
  #your script 
library(lubridate) #for working with dates
library(ggplot2)  #for creating graphs
library(scales)   #to access breaks/formatting functions
library(gridExtra) #for arranging plots
library(grid)   #for arrangeing plots
library(dplyr)  #for subsetting by season

#set working directory to ensure R can find the file we wish to import
#setwd("working-dir-path-here")

#daily HARV met data, 2009-2011
harMetDaily.09.11 <- read.csv(file="NEON-DS-Met-Time-Series/HARV/FisherTower-Met/Met_HARV_Daily_2009_2011.csv",
                     stringsAsFactors = FALSE)

#covert date to POSIXct date-time class
harMetDaily.09.11$date <- as.POSIXct(harMetDaily.09.11$date)

#monthly HARV temperature data, 2009-2011
#harTemp.monthly.09.11<-read.csv(file="NEON-DS-Met-Time-Series/HARV/FisherTower-Met/Temp_HARV_Monthly_09_11.csv",
#                                stringsAsFactors=FALSE)

#convert datetime from chr to datetime class & rename date for clarification
#harTemp.monthly.09.11$date <- as.POSIXct(harTemp.monthly.09.11$datetime)
```

##GGPLOT Facets

Facets allow us to plot subsets of data in one cleanly organized panel. We use
 `facet_grid()` to create a plot of a particular variable subsetted by a particular
 "group".
 
Let's plot air temperature as we did previously. We will name the `ggplot`
object `AirTempDaily`.

```{r plot-airt }

AirTempDaily <- ggplot(harMetDaily.09.11, aes(date, airt)) +
           geom_point() +
           ggtitle("Daily Air Temperature NEON Harvard Forest\n 2009-2011") +
            xlab("Date") + ylab("Temperature (C)") +
            scale_x_datetime(labels=date_format ("%m-%y"))+
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

AirTempDaily
```
 
This plot tells us a lot about the annual increase and decrease of temperature
at the NEON Harvard Forest field site. However, what is we wanted to plot each
year's worth of data individually?

If we use the `facet()` element in `ggplot`, we can create facets or a panel of 
plots that are grouped by a particular category or time period. To create a 
a plot for each year, we will first need a year column in our data to use a subset 
factor. We created a year column did this in the 
[{{site.baseurl}}R/Time-Series-Subset-dplyr/](DPLYR subset timeseries lesson)
using the `year` function in the `lubridate` package.

 
```{r plot-by-year}
#add year column to daily values
harMetDaily.09.11$year <- year(harMetDaily.09.11$date)

#view year column head and tail
head(harMetDaily.09.11$year)
tail(harMetDaily.09.11$year)

```


## Facet by Year
Once we have a column that can be used to group or subset our data, we can 
create a facetted plot - plotting each year's worth of data in 
an individual, named panel.

```{r plot-facet-year }
#run this code to plot the same plot as before but with one plot per season
AirTempDaily + facet_grid(. ~ year)
```

Oops - what happened? The plot did not render because we added the `year` column
after creating the `ggplot` object `AirTempDaily`. Let's rerun the ggplot code
to ensure our newly added column is recognized.

```{r plot-facet-year-2}
AirTempDaily <- ggplot(harMetDaily.09.11, aes(date, airt)) +
           geom_point() +
           ggtitle("Daily Air Temperature NEON Harvard Forest\n 2009-2011") +
            xlab("Date") + ylab("Temperature (C)") +
            scale_x_datetime(labels=date_format ("%m-%y"))+
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#facet plot by year
AirTempDaily + facet_grid(. ~ year)
```

The faceted plot is interesting, however the x-axis on each plot is month-day-year.
This means that the data for 2009 is on the left end of the plot and the data for
2011 is on the right end (the end of the x axis) of the 2011 plot. Our plots might be 
easier to compare visually, if the days were julian days rather than date. 

```{r plot-precip-jd }

AirTempDaily_jd <- ggplot(harMetDaily.09.11, aes(jd, airt)) +
           geom_point() +
           ggtitle("Daily Precipitation Harvard Forest\n 2009-2011") +
            xlab("Julian Day") + ylab("Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
AirTempDaily_jd + facet_grid(. ~ year)

```

Using Julian Day, our plots are visually easier to compare. Arranging our plots 
this way, side by side, allows us to quickly scan for differences
along the Y axis. Notice any differences in min vs max air temperature across the 
three years?

##Arranging Facets

We can rearrange the facets in different ways, too.

```{r rearrange-facets }

#move labels to the RIGHT and stack all plots
AirTempDaily_jd + facet_grid(year ~ .)


```

If we use `facet_wrap` we can specify the number of columns

```{r rearrange-facets-columns }

#add columns
AirTempDaily_jd + facet_wrap(~year, ncol = 2)


```

##Graph Two Variables on One Plot
Next, let's explore the relationship between two variables - air temperature
and soil temperature. We might expect soil temperature to fluctuate with
changes in air temperature over time.  

We will use `ggplot()` to plot `airt` and `s10t` (soil temperature
10 cm below the ground). 

```{r plot-airt-soilt }

airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
           xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

airSoilTemp_Plot

```

The plot above suggests a relationship between the air and soil temperature as
we might expect. However, it clumps all three years worth of data into one plot. 
Let's create a stacked facetted plot of air vs. soil temperature grouped by year.

Lucky for us, we can do this quickly with one line of code - reusing the plot we
created above.

```{r faceted-temp-plots }
#create faceted panel
airSoilTemp_Plot + facet_grid(year ~ .)
```

Have a close look at the data. Are there any noticable min / max temperature 
differences between the three years?

<div id="challenge" markdown="1">

##Challenge

Create a facetted plot of air temperature vs soil temperature by MONTH rather 
than year.

* HINT: To create this plot, you will want to add a month column to our data_frame.
We can use lubridate `month` in the same way we used `year` to add a year column. 

</div>

```{r challenge-answer-temp-month, echo=FALSE }

#add month column to daily values
harMetDaily.09.11$month <- month(harMetDaily.09.11$date)

#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
           xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
airSoilTemp_Plot + facet_wrap(~month, nc=3)

```

##Facetted Plots & Categorical Groups

In the challenge above, we grouped our data by MONTH - specificed by a numeric
value between 1 (January) and 12 (December). However, what if we wanted to 
organize our plots using a categorical (character) group such as month NAME?
Let's do that next.

If we want to group our data by month NAME, we first need to create a month name
column in our `data_frame`. We can create this column using the following syntax:

`format(harMetDaily.09.11$date,"%B")`

Which tells `R` to extract the month name (`%B`) from the date field.

```{r extract-month-name }
#add text month name column
harMetDaily.09.11$month_name <- format(harMetDaily.09.11$date,"%B")

#view head and tail
head(harMetDaily.09.11$month_name)
tail(harMetDaily.09.11$month_name)

#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
            xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
airSoilTemp_Plot + facet_wrap(~month_name, nc=3)

```

Great! We've created a nice set of plots by month. However, what is the order
or the plots? It looks like `R` is ordering things alphabetically yet we know
that months are ordinal not character strings. To account for order, we can 
reassign the `month_name` field to a `factor`. This will allow us to specify
an order to each factor "level" (each month is a level).

The syntax for this operation is 

1. turn field into a factor: `factor(fieldName) `
2. designate the `levels` using a list `c(level1, level2, level3)`

In our case, each level will be a month.

```{r factor }
#order the factors
harMetDaily.09.11$month_name = factor(harMetDaily.09.11$month_name, 
                                      levels=c('January','February','March',
                                               'April','May','June','July',
                                               'August','September','October',
                                               'November','December'))
```

Once we have specified the factor column and its associated levels, we can plot 
again. Remember, that because we have modified a column in our `data_frame`, we
need to rerun our `ggplot` code.

```{r plot-by-month-levels }

#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature 2009-2011\n NEON Harvard Forest Field Site") +
            xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
airSoilTemp_Plot + facet_wrap(~month_name, nc=3)

```


##Subset by Season - ADVANCED
Sometimes we want to group data by custom time periods. For example, we might
want to group by season. However, the definition of various seasons may vary by 
region which means we need to manually define each time period.

In the next section, we will add a season column to our data using a manually
defined query. Our field site is Harvard Forest (Massachusetts), located
in the northeastern portion of the United States. We can divide this 
region into 4 seasons as follows: 

 * Winter: December - February
 * Spring: March - May 
 * Summer: June - August
 * Fall: September - November 
 
In order to subset the data by season we will use the `dplyr` package.  We
can use the numeric month column that we added to our data earlier in this lesson.

```   {r subsetting-by-season-1}
#add month to data_frame - note we already performed this step above.
harMetDaily.09.11$month  <- month(harMetDaily.09.11$date)

#view head and tail of column
head(harMetDaily.09.11$month)
tail(harMetDaily.09.11$month)
```

We can use `mutate()` and a set of `ifelse` statements to create a new categorical
variable called `season` by grouping three months together. 

Within `dplyr` `%in%` is short-hand for "contained within". So the syntax:

`ifelse(month %in% c(12, 1, 2), "Winter",`

Can be read:

> if the `month` column value is 12 or 1 or 1, then assign the value "Winter"

Our `ifelse` statement ends with the following:

`ifelse(month %in% c(9, 10, 11), "Fall", "Error")`

We can translate this as:

> if the `month` column value is 9 or 10 or 11, then assign the value "Winter"

The last portion `, "Error"` tells `R` that if a `month` column value does not 
fall within any of the criteria laid out in previous `ifelse` statements, to 
assign the column the value of "Error". 


``` {r  subsetting-by-season-2}
harMetDaily.09.11 <- harMetDaily.09.11 %>% 
  mutate(season = 
           ifelse(month %in% c(12, 1, 2), "Winter",
           ifelse(month %in% c(3, 4, 5), "Spring",
           ifelse(month %in% c(6, 7, 8), "Summer",
           ifelse(month %in% c(9, 10, 11), "Fall", "Error")))))


#check to see if this worked
head(harMetDaily.09.11$month)
head(harMetDaily.09.11$season)
tail(harMetDaily.09.11$month)
tail(harMetDaily.09.11$season)
```

Now that we have a season column, we can plot our data by season!

```{r plot-by-season}

#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature 2009-2011\n NEON Harvard Forest Field Site") +
            xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#run this code to plot the same plot as before but with one plot per season
airSoilTemp_Plot + facet_grid(. ~ season)
```

Note, that once again, we re-ran our `ggplot` code to make sure our new column
is recognized by `R`. We can experiment with various facet layouts next.

``` {r plot-by-season2}

# for a landscape orientation of the plots we change the order of arguments in
    #facet_grid():
airSoilTemp_Plot + facet_grid(season ~ .)



```

<div id="challenge" markdown="1">

##Challenge 

Convert the season column that we just created to a factor and organize the seasons
chronologically as follows: Winter, Spring, Summer, Fall.

Create a new faceted plot that is 2 x 2 (2 columns of plots).

</div>

``` {r assigning-level-to-season, echo=FALSE  }

#create factor / assign levels
harMetDaily.09.11$season<- factor(harMetDaily.09.11$season, 
                                  level=c("Winter","Spring","Summer","Fall")) 

#check to make sure it worked
str(harMetDaily.09.11$season)

#rerun original par.precip code to incorporate the levels. 
airSoilTemp_Plot_season <- ggplot(harMetDaily.09.11,aes(prec, part)) +
         geom_point(na.rm=TRUE) +    #removing the NA values
        ggtitle("Seasonal Air vs Soil Temperature 2009-2011 \n NEON Harvard Forest Site") +
         theme(plot.title = element_text(lineheight=.8, face="bold",size = 20)) +
         theme(text = element_text(size=20)) +
         xlab("Total Precipitation (mm)") + ylab("Mean Total PAR")
           
#new facetted plots
airSoilTemp_Plot_season + facet_wrap(~ season, nc=2)


```


<div id="challenge" markdown="1">

Use the `NEON-DS-Met-Time-Series/HARV/FisherTower-Met/hf001-04-monthly-m.csv` 
`.csv` file. This contains monthy average data for the NEON Harvard Forest field
site. Create a faceted plot of annual air temperature for each year of data
in the file (2001-2015)

* HINT: in this case, we will be converting a year-month field. To do this with
a base R date class, we need an associated day. We can add this using:

`as.Date(paste(met_monthly_HARV$date,"-01",sep=""))`

If we wanted we could use the `zoo` package to achieve this as follows:

`library(zoo)`
`as.Date(as.yearmon(met_monthly_HARV$date))`

Experiment on your own to figure out the methods that you prefer!

</div>

```{r plot-monthly-data, echo=FALSE }

met_monthly_HARV <- read.csv("NEON-DS-Met-Time-Series/HARV/FisherTower-Met/hf001-04-monthly-m.csv", stringsAsFactors = FALSE)

#convert to date time - add a day "01" to each date to support this in base R
met_monthly_HARV$date <- as.Date(paste(met_monthly_HARV$date,"-01",sep=""))

#add year
met_monthly_HARV$year <- year(met_monthly_HARV$date)

#add month
met_monthly_HARV$month <- factor(month(met_monthly_HARV$date))


#create plot
#rerun original par.precip code to incorporate the levels. 
long_term_temp <- ggplot(met_monthly_HARV,aes(month, airt)) +
         geom_point(na.rm=TRUE) +    #removing the NA values
        ggtitle("Air Temperature 2001-2015 \n NEON Harvard Forest Site") +
         theme(plot.title = element_text(lineheight=.8, face="bold",size = 20)) +
         theme(text = element_text(size=20)) +
         xlab("Total Precipitation (mm)") + ylab("Mean Total PAR")
           
#new facetted plots
long_term_temp + facet_wrap(~ year, nc=3)
```

***


#Plot NDVI & PAR using Daily Data

##NDVI Data
Normalized Difference Vegetation Index (NDVI) is an indicator of how green vegetation is.  NDVI is derrived from remote sensing data based on a ratio the reflectance of visible red spectra and near-infrared specra.  The NDVI values vary from -1.0 to 1.0.  

The imagery data used to create this NDVI data were collected over
the National Ecological Observatory Network's
<a href="http://www.neoninc.org/science-design/field-sites/harvard-forest" target="_blank" >Harvard Forest</a>
field site.  
The imagery was created by the U.S. Geological Survey (USGS) using a 
<a href="http://eros.usgs.gov/#/Find_Data/Products_and_Data_Available/MSS" target="_blank" >  multispectral scanner</a>
on a <a href="http://landsat.usgs.gov" target="_blank" > Landsat Satellite </a>.
The data files are Geographic Tagged Image-File Format (GeoTIFF).  
A tutorial,
[Extract NDVI Summary Values from a Raster Time Series]({{ site.baseurl}}/R/Extract-NDVI-From-Rasters-In-R/), 
explains how to create this NDVI file based on Raster data. 

###Read In NDVI Data
We need to read in the 2011 NDVI data for the Harvard Forest. A .csv file is
within `NDVI_ForAtmosData` subdirectory in the `AtmosData` directory.
```{r read-NDVI}
#first read in the NDVI CSV data
NDVI.2011 <- read.csv(file="NEON-DS-Met-Time-Series/HARV/NDVI/meanNDVI_HARV_2011.csv"
                      , stringsAsFactors = FALSE)
#check out the data
str(NDVI.2011)
head(NDVI.2011)
```

#Challenge: Convert Date in Character Class to a Date-Time Class
The Date data is currently in the character class convert the data to a date
class. 

``` {r challenge-code-convert-date, include=TRUE, results="hide", echo=FALSE}
#convert chr class Date to date class Date
NDVI.2011$Date<- as.Date(NDVI.2011$Date)
#double check
str(NDVI.2011)
```

##Subset Only the 2011 Micrometeology Data
First lets get just 2011 from the `harmet.Daily` data since that is the only
year for which we have NDVI data.

```{r dplyr-to-subset}
#Use dplyr to subset only 2011 data
harMet.daily2011 <- harMetDaily.09.11 %>% 
  mutate(year = year(date)) %>%   #need to create a year only column first
  filter(year == "2011")

#convert data from POSIX class to Date class; both "date" vars. now Date class
harMet.daily2011$date<-as.Date(harMet.daily2011$date)
```

In this data set we have the following variables:  

* 'X': an integer representing each row
* meanNDVI: the daily total NDVI for that area.  ("Mean" comes from the fact that the value is a mean of all pixels in the original raster).
* site: all NDVI values are from the Harvard Forest
* year: all values are from 2011
* julianDay: the numeric day of the year
* Date: a date in format "YYYY-MM-DD".

## Two y-axes or Side-by-Side Plots?
When we have different types of data like NDVI (scale: 0-1 index units) and PAR
(scale: 0-65.8 mole per meter squared) that we want to plot over time, we cannot
simply plot them on the same plot as they have different y-axes.  

One option, would be to plot both data types in the same plot space but each
having it's own axis.  However, there is a line of graphical representation 
thought that this is not a good practice.  The creator of `ggplot2` ascribes to
this dislike of different y-axes and so neither `qplot` nor `ggplot` have this
functionality.  

Instead, plots of different types of data can be plotted next to each other to 
allow for comparison.  Depending on how the plots are being viewed they can have
a verticle or horizontal arrangement.  

Following this second option, we will create a plot for each variable using the
same time variable (Julian day) as our x-axis.

Then we will plot the two plots in the same viewer so we can more easily compare
them.  

``` {r plot-PAR-NDVI}
#create plot of julian day vs. PAR
plot.par.2011 <- ggplot(harMet.daily2011, aes(date, part))+
  geom_point(na.rm=TRUE) +
  ggtitle("Daily PAR at Harvard Forest, 2011")+
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=20))

plot.NDVI.2011 <- ggplot(NDVI.2011, aes(Date, meanNDVI))+
  geom_point(colour = "forestgreen", size = 4) +
  ggtitle("Daily NDVI at Harvard Forest, 2011")+
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=20))
 
#display the plots together
grid.arrange(plot.par.2011, plot.NDVI.2011) 
```

This is nice but a bit confusing as the time on our x-axis doesn't fully line
up.  To fix this we can assign the same min and max to both x-axes so that
they align.  We can also label the axes 

``` {r plot-same-xaxis}
plot2.par.2011 <- plot.par.2011 +
  scale_x_date(labels = date_format("%b %d"),
               breaks = "3 months", minor_breaks= "1 week",
               limits=c(min(NDVI.2011$Date),max=max(NDVI.2011$Date)))+
  ylab("Total PAR") + xlab ("")
 

plot2.NDVI.2011 <- plot.NDVI.2011 +
  scale_x_date(labels = date_format("%b %d"),
               breaks = "3 months", minor_breaks= "1 week",
               limits=c(min(NDVI.2011$Date),max=max(NDVI.2011$Date)))+
  ylab("Total NDVI") + xlab ("Date")


grid.arrange(plot2.par.2011, plot2.NDVI.2011) 
```

#Challenge: Plot Air Temperature and NDVI
Create a complementary plot pairing with Air Temperateure and NDVI.  Choose
colors and symobls that show the data well.  Finally, plot air temperature, PAR,
and NDVI in a single window to ease comparisons.  

``` {r challengeplot-same-xaxis, echo=FALSE}
plot.airt.2011 <- ggplot(harMet.daily2011, aes(date, airt))+
  geom_point(colour="darkblue", na.rm=TRUE) +
  ggtitle("Average Air Temperature\n Harvard Forest 2011")+
  scale_x_date(labels = date_format("%b %d"),
               breaks = "3 months", minor_breaks= "1 week",
               limits=c(min(NDVI.2011$Date),max=max(NDVI.2011$Date)))+
  ylab("Celcius") + xlab ("")+
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=20))

grid.arrange(plot.airt.2011, plot2.NDVI.2011) 

grid.arrange(plot2.par.2011, plot.airt.2011, plot2.NDVI.2011) 
```


##Two plots with One x-axis.  
We are able to nicely see the three different variables.  However, we waste a
lot of space to repeating the x-axes and the titles.  Instead of three seperate
plots we could alternatively, use facets and plot all the variables of interests
(NDVI, air temperature, precipiation, and PAR) on a single x-axis.  To do this
we'll 
use `melt()` from the `reshape2` package. `melt` tranforms the data from a wide
format (columns of different variables with values in them), to a long format 
(column of variables with a column of values) organized according to a specified
variable.  

```{r plot-same-x-axis-1}

library(reshape2)  #allows us to "melt" dataframes from "wide" to "long"

#merge the two data frames by date and retain all 'harMet.daily
harMetNDVIall.daily.2011<- merge(harMet.daily2011, NDVI.2011, by.x = "date", 
                              by.y = "Date", all.x=TRUE)

#convert from "wide" form to "long" form
harMetNDVI.daily.2011.long<-melt(harMetNDVIall.daily.2011, id ="date")
```

Once we have the data in the long form we can subset and then plot the data. 

``` {r plot-same-x-axis-2}
#subset to retain just the variables of interest.  The vertical bar character
# means "OR".
harMetNDVI.daily.2011.select<-subset(harMetNDVI.daily.2011.long,
                                variable=="meanNDVI"| variable== "prec"|
                                variable == "airt" | variable == "part")

NDVI.harMet.facet.plot<-ggplot(harMetNDVI.daily.2011.select,
                               aes(date, value), group=variable) +
  geom_point() +
  facet_grid(variable~., scales="free") +   #specify facets & y-axis can vary
  ggtitle("Harvard Forest 2011") +
  scale_x_date(labels = date_format("%b %d"),  #abbreviated month & day
               breaks = "3 months", minor_breaks= "1 month") +  #where grid is
  xlab ("Date") + ylab ("Value") +
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=10)) 

NDVI.harMet.facet.plot

```

