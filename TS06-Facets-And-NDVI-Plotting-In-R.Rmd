---
layout: post
title: "Lesson 06: Plot using Facets and Plot Time Series with NDVI data"
date:   2015-10-19
authors: [Megan A. Jones, Marisa Guarinello, Courtney Soderberg]
contributors: [Leah Wasser]
dateCreated: 2015-10-22
lastModified: `r format(Sys.time(), "%Y-%m-%d")`
category:  
tags: [spatio-temporal, time-series, phenology]
mainTag: time-series
description: "This lesson teaches how to plot subsetted time series data using
the `facets()` function (e.g., plot by season) and to plot time series data with
NDVI."
code1: TS06-Facets-And-NDVI-Plotting-In-R.R
image:
  feature: NEONCarpentryHeader_2.png
  credit: A collaboration between the National Ecological Observatory Network (NEON) and Data Carpentry
  creditlink: http://www.neoninc.org
permalink: /R/Time-Series-Plot-Facets-NDVI
comments: false
---

{% include _toc.html %}

##About
This lesson teaches how to plot subsetted time series data using
the `facets()` function (e.g., plot by season) and to plot time series data with
NDVI.

**R Skill Level:** Intermediate - you've got the basics of `R` down.

<div id="objectives" markdown="1">

###Goals / Objectives
After completing this activity, you will:

 * Know how to use `facets()` in the ggplot2 package.
 * Be able to combine different types of data into one plot.

**To complete this lesson:** you will need the most current version of R, and 
preferably RStudio, loaded on your computer.

####R Libraries to Install
* **ggplot:** `install.packages("ggplot2")`
* **scales:** `install.packages("scales")`
* **gridExtra:** `install.packages("gridExtra")`
* **grid:** `install.packages("grid")`
* **dplyr:** `install.packages("dplyr")`
* **reshape2:** `install.packages("reshape2")`

####Data to Download
<a href="https://ndownloader.figshare.com/files/3579861" class="btn btn-success"> Download Atmospheric Data</a>

The data used in this lesson were collected at Harvard Forest which is
an National Ecological Observatory Network  
<a href="http://www.neoninc.org/science-design/field-sites/harvard-forest" target="_blank"> field site</a>. 
These data are proxy data for what will be available for 30 years
on the [NEON data portal](http://data.neoninc.org/ "NEON data")
for both Harvard Forest and other field sites located across the United States.

**Set Working Directory:** This lessons assumes that you have set your working 
directory to the location of the downloaded and unzipped data subset. [An overview
of setting the working directory in `R` can be found here.]({{site.baseurl}}/R/Set-Working-Directory "R Working Directory Lesson") 
lesson prior to beginning this lesson.

**Challenge Code:** NEON Data lesson often contain challenges that reinforce 
learned skills. If available, the code for challenge solutions is found in a 
downloadable `R` script available on the footer of each lesson page.

###Additional Resources

####Skills Needed
This lessons assumes familiarity with both the `dplyr` package and `ggplot()` in
the `ggplot2` package.  If you are not comfortable with either of these we
recommend starting with the [Subset & Manipulate Time Series Data with `dplyr` lesson]({{site.baseurl}}/R/Time-Series-Subset-dplyr/ "Learn dplyr") 
and the [Plotting Time Series with ggplot in R lesson]({{site.baseurl}}/R/Time-Series-Plot-ggplot/ "Learn ggplot")  
respectively, to gain familiarity.


</div>

#Plotting Subsetted Data Using Facets
 
In this lesson we will learn how to create facetted plots - that is a panel
of plots each of which represents a particular data_frame subset - for example
year or season.

###Load the Data
We will use the daily micro-meteorology data for 2009-2011 from the Harvard
Forest. If you do not have this data loaded into an `R` `data_frame`, please 
load them, and convert date-time columns to a date-time class now.

```{r load-data}
#Remember it is good coding technique to add additional libraries to the top of
  #your script 
library(lubridate) #for working with dates
library(ggplot2)  #for creating graphs
library(scales)   #to access breaks/formatting functions
library(gridExtra) #for arranging plots
library(grid)   #for arrangeing plots
library(dplyr)  #for subsetting by season

#set working directory to ensure R can find the file we wish to import
#setwd("working-dir-path-here")

#daily HARV met data, 2009-2011
harMetDaily.09.11 <- read.csv(file="NEON-DS-Met-Time-Series/HARV/FisherTower-Met/Met_HARV_Daily_2009_2011.csv",
                     stringsAsFactors = FALSE)

#covert date to POSIXct date-time class
harMetDaily.09.11$date <- as.POSIXct(harMetDaily.09.11$date)

#monthly HARV temperature data, 2009-2011
harTemp.monthly.09.11<-read.csv(file="NEON-DS-Met-Time-Series/HARV/FisherTower-Met/Temp_HARV_Monthly_09_11.csv",
                                stringsAsFactors=FALSE)

#convert datetime from chr to datetime class & rename date for clarification
harTemp.monthly.09.11$date <- as.POSIXct(harTemp.monthly.09.11$datetime)
```

##GGPLOT Facets

Facets allow us to plot subsets of data in one cleanly organized panel. We use
 `facet_grid()` to create a plot of a particular variable subsetted by a particular
 "group".
 
To begin, let's create a faceted plot using year as our subset group. To do this,
we need a year column in our data to use a subset factor. We
did this in the 
[{{site.baseurl}}R/Time-Series-Subset-dplyr/](DPLYR subset timeseries lesson.)
using the `year` function in the `lubridate` package.

 
```{r plot-by-year}
#add year column to daily values
harMetDaily.09.11$year <- year(harMetDaily.09.11$date)
```

Next, let's plot air temperature as we did previously. We will name the `ggplot`
object `PrecipDaily`.

```{r plot-precip }

AirTempDaily <- ggplot(harMetDaily.09.11, aes(date, airt)) +
           geom_point() +
           ggtitle("Daily Air Temperature NEON Harvard Forest\n 2009-2011") +
            xlab("Date") + ylab("Temperature (C)") +
            scale_x_datetime(labels=date_format ("%m-%y"))+
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

AirTempDaily
```

## Facet by Year
Next, we can create a facetted plot - plotting each  year's worth of data in 
an individual, named panel.

```{r plot-facet-year }
#run this code to plot the same plot as before but with one plot per season
AirTempDaily + facet_grid(. ~ year)
```

The faceted plot is interesting, however the data are plotted by year, which means
that the range of data in the x axis varies between facets. Our plots might be 
easier to compare visually, if the days were julian days rather than date. 

```{r plot-precip-jd }

AirTempDaily_jd <- ggplot(harMetDaily.09.11, aes(jd, airt)) +
           geom_point() +
           ggtitle("Daily Precipitation Harvard Forest\n 2009-2011") +
            xlab("Julian Day") + ylab("Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
AirTempDaily_jd + facet_grid(. ~ year)

```

Arranging our plots this way, side by side, allows us to quickly scan for differences
along the Y axis. Notice any differences in min vs max air temperature across the 
three years?

##Arranging Facets

We can organize our plots too.

```{r rearrange-facets }

#move labels to the RIGHT and stack all plots
AirTempDaily_jd + facet_grid(year ~ .)


```

If we use `facet_wrap` we can specify the number of columns

```{r rearrange-facets-columns }

#add columns
AirTempDaily_jd + facet_wrap(~year, ncol = 2)


```

##Graph Two Variables on One Plot
Next, let's explore the relationship between two variables - air temperature
and soil temperature. We might expect soil temperature to fluctuate according to
changes in air temperature over time.  

We will use `ggplot()` to plot `airt` and `s10t` (representing the soil temperature
10 cm below the ground. 

```{r plot-airt-soilt }

airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
           xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

airSoilTemp_Plot



```

The plot above is interesting and suggests a relationship between the two variables.
However, it clumps all three years worth of data into one plot. Let's create a 
stacked facetted plot of air vs soil temperature grouped by year.

Lucky for us, we can do this quickly with one line of code - reusing the plot we
created above!

```{r faceted-temp-plots }
#create faceted panel
airSoilTemp_Plot + facet_grid(year ~ .)
```

Have a close look at the data. Are there any noticable min / max temperature 
differences between the three years?

<div id="challenge" markdown="1">

##Challenge

Create a facetted plot of air temperature vs soil temperature by MONTH rather 
than year. A few hints to help you along the way:

1. To create this plot, you will want to add a month column to our data_frame.
We can use lubridate `month` in the same way we used `year` to add a year column. 
2. Once you have added the month column, you will need to rerun your ggplot code
to ensure the new month field is recognized when you render the plot using 
facets.

</div>

```{r challenge-answer-temp-month, echo=FALSE }

#add month column to daily values
harMetDaily.09.11$month <- month(harMetDaily.09.11$date)

#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
           xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
airSoilTemp_Plot + facet_wrap(~month, nc=3)



```

<div id="challenge" markdown="1">

##Facet Challenge 2

Create a second facetted plot, but this time use the full month names (e.g. January,
February, March) to group your facets. A few hints regarding how to do this follow:

1. We can use `format(harMetDaily.09.11$date,"%B")` to add a month column using the full month 
names for prettier plotting.
2. When you plot by month, you might notice that the years are not in the desired order, rather
they are arranged alphabetically. To account for this, you can reassign the 
month_name column to a factor, and order the factor levels manually.

The code below assigned the `month_name` field to a factor class. It then defines
the `levels` in the order that we wish to see them. 

```{r factor, eval=FALSE}
#order the factors
harMetDaily.09.11$month_name = factor(harMetDaily.09.11$month_name, 
                                      levels=c('January','February','March',
                                               'April','May','June','July',
                                               'August','September','October',
                                               'November','December'))
```
</div>

```{r answers-challenge-p2, echo=FALSE }

#add text month
harMetDaily.09.11$month_name <- format(harMetDaily.09.11$date,"%B")

#order the factors
harMetDaily.09.11$month_name = factor(harMetDaily.09.11$month_name, 
                                      levels=c('January','February','March',
                                               'April','May','June','July',
                                               'August','September','October',
                                               'November','December'))

#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
            xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))

#create faceted panel
airSoilTemp_Plot + facet_wrap(~month_name, nc=3)

```


##Subset by Season - ADVANCED
Sometimes we want to group data by unique time periods. For example, we might
want to group by season. However, the definition of various seasons may vary by 
region which means we might want to manually define each time period.

In the next section, we will add a season column to our data using a manually
defined query. We are using data from Harvard Forest in Massachusetts
in the northeastern portion of the United States. We can divide this 
region into 4 seasons as follows: 

 * Winter: December - February
 * Spring: March - May 
 * Summer: June - August
 * Fall: September - November 
 
In order to subset the data by season we will use the `dplyr` package.  We
can use the month column that we added to our data in the challenge above.

```   {r subsetting-by-season-1}
#add month
harMetDaily.09.11$month  <- month(harMetDaily.09.11$date)

#check structure of this variable
head(harMetDaily.09.11$month)
```

We can now use `mutate()` and an `ifelse` statement to create a new variable
called `season` by grouping three months together. 

Within `dplyr` `%in%` is short-hand for "or"; the 3rd line of code essentially
says "If the month variable is equal to 12 or  1 or  2, set the season
variable to Winter". The "Error" at the end is what will be printed in the 
column if the month does not equal any of the month dates specified.  

``` {r  subsetting-by-season-2}
harMetDaily.09.11 <- harMetDaily.09.11 %>% 
  mutate(season = 
           ifelse(month %in% c(12, 1, 2), "Winter",
           ifelse(month %in% c(3, 4, 5), "Spring",
           ifelse(month %in% c(6, 7, 8), "Summer",
           ifelse(month %in% c(9, 10, 11), "Fall", "Error")))))


#check to see if this worked
head(harMetDaily.09.11$month)
head(harMetDaily.09.11$season)
tail(harMetDaily.09.11$month)
tail(harMetDaily.09.11$season)
```

Now that we can plot our data by season!

```{r plot-by-season}

#run this code to plot the same plot as before but with one plot per season
airSoilTemp_Plot + facet_grid(. ~ season)
```

It didn't work!  Why? 

We added the season variable to `harMetDaily.09.11` after we created the
original `airSoilTemp_Plot` plot. We need to re-run the `airSoilTemp_Plot` code 
again so that `season` is now included in the data (go back and re-run that code). 

``` {r tempPlot-rerun }
#recreate plot
airSoilTemp_Plot <- ggplot(harMetDaily.09.11, aes(airt, s10t)) +
           geom_point() +
           ggtitle("Air vs. Soil Temperature NEON Harvard Forest Field Site\n 2009-2011") +
            xlab("Air Temperature (C)") + ylab("Soil Temperature (C)") +
           theme(plot.title = element_text(lineheight=.8, face="bold",
                 size = 20)) +
           theme(text = element_text(size=18))


```

Now that we've rerun the plot code, the facet option should work. 

``` {r plot-by-season2}
airSoilTemp_Plot + facet_grid(. ~ season)

# for a landscape orientation of the plots we change the order of arguments in
    #facet_grid():
airSoilTemp_Plot + facet_grid(season ~ .)


#and another arrangement of plots:
airSoilTemp_Plot + facet_wrap(~season, ncol = 2)

```




How does our ability to see patterns in the data vary depending on which
arrangement the graphs are in? 

##Defining the Order of Facetted Plots
Notice how our facetted plots are currently show up as "fall", "spring",
"summer", "winter".  As no level is assigned the data are class character, `R`
simply arranges them in alphabetical order.  However, "fall", "spring", 
"summer", "winter" do have a specified order to them.  It doesn't mater which
season starts the cycle but they should be in order to ease our understanding
of annual cycles. 

In order to create a logical order we need to assign levels to the seasons. We
can do this by assigning the seasons as a factor with a defined order (or 
level).  

``` {r assigning-level-to-season  }
harMetDaily.09.11$season<- factor(harMetDaily.09.11$season, level=c("spring",
                                                    "summer","fall","winter")) 

#check to make sure it worked
str(harMetDaily.09.11$season)

#rerun original par.precip code to incorporate the levels. 
par.precip <- ggplot(harMetDaily.09.11,aes(prec, part)) +
         geom_point(na.rm=TRUE) +    #removing the NA values
        ggtitle("Daily Precipitation and PAR at Harvard Forest") +
         theme(plot.title = element_text(lineheight=.8, face="bold",size = 20)) +
         theme(text = element_text(size=20)) +
         xlab("Total Precipitation (mm)") + ylab("Mean Total PAR")
           
#new facetted plots
par.precip + facet_grid(. ~ season)

```

We now how a plot with the seasons in a logical order. 

#Challenge: Compare Precipitation and Air Temperature Across Seasons
1) Using the same data create a faceted plot showing the relationship between 
precipitation and air temperature across the seasons.  Create the figure with
"winter" as the first facetted plot.   
2) Compare how different orientations of the plots highlight different patterns.

``` {r  challenge-code-prec.airtemp, echo=FALSE}
harMetDaily.09.11$season<- factor(harMetDaily.09.11$season, level=c("winter",
                                                  "spring", "summer", "fall"))
prec.airtemp <- ggplot(harMetDaily.09.11,aes(airt, prec)) +
           geom_point(na.rm=TRUE) +    #removing the NA values
           ggtitle("Harvard Forest\n 2009-2011") +
           theme(plot.title = element_text(lineheight=.8, face="bold",size = 20)) +
           theme(text = element_text(size=20)) +
           xlab("Air Temperature (Celcius)") + ylab("Precipitation (daily mm)")

prec.airtemp + facet_grid(.~season)
prec.airtemp + facet_grid(season~.)

```

#Plot NDVI & PAR using Daily Data

##NDVI Data
Normalized Difference Vegetation Index (NDVI) is an indicator of how green vegetation is.  NDVI is derrived from remote sensing data based on a ratio the reflectance of visible red spectra and near-infrared specra.  The NDVI values vary from -1.0 to 1.0.  

The imagery data used to create this NDVI data were collected over
the National Ecological Observatory Network's
<a href="http://www.neoninc.org/science-design/field-sites/harvard-forest" target="_blank" >Harvard Forest</a>
field site.  
The imagery was created by the U.S. Geological Survey (USGS) using a 
<a href="http://eros.usgs.gov/#/Find_Data/Products_and_Data_Available/MSS" target="_blank" >  multispectral scanner</a>
on a <a href="http://landsat.usgs.gov" target="_blank" > Landsat Satellite </a>.
The data files are Geographic Tagged Image-File Format (GeoTIFF).  
A tutorial,
[Extract NDVI Summary Values from a Raster Time Series]({{ site.baseurl}}/R/Extract-NDVI-From-Rasters-In-R/), 
explains how to create this NDVI file based on Raster data. 

###Read In NDVI Data
We need to read in the 2011 NDVI data for the Harvard Forest. A .csv file is
within `NDVI_ForAtmosData` subdirectory in the `AtmosData` directory.
```{r read-NDVI}
#first read in the NDVI CSV data
NDVI.2011 <- read.csv(file="AtmosData/NDVI_ForAtmosData/meanNDVI_HARV_2011.csv"
                      , stringsAsFactors = FALSE)
#check out the data
str(NDVI.2011)
head(NDVI.2011)
```

#Challenge: Convert Date in Character Class to a Date-Time Class
The Date data is currently in the character class convert the data to a date
class. 

``` {r challenge-code-convert-date, include=TRUE, results="hide", echo=FALSE}
#convert chr class Date to date class Date
NDVI.2011$Date<- as.Date(NDVI.2011$Date)
#double check
str(NDVI.2011)
```

##Subset Only the 2011 Micrometeology Data
First lets get just 2011 from the `harmet.Daily` data since that is the only
year for which we have NDVI data.

```{r dplyr-to-subset}
#Use dplyr to subset only 2011 data
harMet.daily2011 <- harMetDaily.09.11 %>% 
  mutate(year = year(date)) %>%   #need to create a year only column first
  filter(year == "2011")

#convert data from POSIX class to Date class; both "date" vars. now Date class
harMet.daily2011$date<-as.Date(harMet.daily2011$date)
```

In this data set we have the following variables:  

* 'X': an integer representing each row
* meanNDVI: the daily total NDVI for that area.  ("Mean" comes from the fact that the value is a mean of all pixels in the original raster).
* site: all NDVI values are from the Harvard Forest
* year: all values are from 2011
* julianDay: the numeric day of the year
* Date: a date in format "YYYY-MM-DD".

## Two y-axes or Side-by-Side Plots?
When we have different types of data like NDVI (scale: 0-1 index units) and PAR
(scale: 0-65.8 mole per meter squared) that we want to plot over time, we cannot
simply plot them on the same plot as they have different y-axes.  

One option, would be to plot both data types in the same plot space but each
having it's own axis.  However, there is a line of graphical representation 
thought that this is not a good practice.  The creator of `ggplot2` ascribes to
this dislike of different y-axes and so neither `qplot` nor `ggplot` have this
functionality.  

Instead, plots of different types of data can be plotted next to each other to 
allow for comparison.  Depending on how the plots are being viewed they can have
a verticle or horizontal arrangement.  

Following this second option, we will create a plot for each variable using the
same time variable (Julian day) as our x-axis.

Then we will plot the two plots in the same viewer so we can more easily compare
them.  

``` {r plot-PAR-NDVI}
#create plot of julian day vs. PAR
plot.par.2011 <- ggplot(harMet.daily2011, aes(date, part))+
  geom_point(na.rm=TRUE) +
  ggtitle("Daily PAR at Harvard Forest, 2011")+
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=20))

plot.NDVI.2011 <- ggplot(NDVI.2011, aes(Date, meanNDVI))+
  geom_point(colour = "forestgreen", size = 4) +
  ggtitle("Daily NDVI at Harvard Forest, 2011")+
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=20))
 
#display the plots together
grid.arrange(plot.par.2011, plot.NDVI.2011) 
```

This is nice but a bit confusing as the time on our x-axis doesn't fully line
up.  To fix this we can assign the same min and max to both x-axes so that
they align.  We can also label the axes 

``` {r plot-same-xaxis}
plot2.par.2011 <- plot.par.2011 +
  scale_x_date(labels = date_format("%b %d"),
               breaks = "3 months", minor_breaks= "1 week",
               limits=c(min(NDVI.2011$Date),max=max(NDVI.2011$Date)))+
  ylab("Total PAR") + xlab ("")
 

plot2.NDVI.2011 <- plot.NDVI.2011 +
  scale_x_date(labels = date_format("%b %d"),
               breaks = "3 months", minor_breaks= "1 week",
               limits=c(min(NDVI.2011$Date),max=max(NDVI.2011$Date)))+
  ylab("Total NDVI") + xlab ("Date")


grid.arrange(plot2.par.2011, plot2.NDVI.2011) 
```

#Challenge: Plot Air Temperature and NDVI
Create a complementary plot pairing with Air Temperateure and NDVI.  Choose
colors and symobls that show the data well.  Finally, plot air temperature, PAR,
and NDVI in a single window to ease comparisons.  

``` {r challengeplot-same-xaxis, echo=FALSE}
plot.airt.2011 <- ggplot(harMet.daily2011, aes(date, airt))+
  geom_point(colour="darkblue", na.rm=TRUE) +
  ggtitle("Average Air Temperature\n Harvard Forest 2011")+
  scale_x_date(labels = date_format("%b %d"),
               breaks = "3 months", minor_breaks= "1 week",
               limits=c(min(NDVI.2011$Date),max=max(NDVI.2011$Date)))+
  ylab("Celcius") + xlab ("")+
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=20))

grid.arrange(plot.airt.2011, plot2.NDVI.2011) 

grid.arrange(plot2.par.2011, plot.airt.2011, plot2.NDVI.2011) 
```


##Two plots with One x-axis.  
We are able to nicely see the three different variables.  However, we waste a
lot of space to repeating the x-axes and the titles.  Instead of three seperate
plots we could alternatively, use facets and plot all the variables of interests
(NDVI, air temperature, precipiation, and PAR) on a single x-axis.  To do this
we'll 
use `melt()` from the `reshape2` package. `melt` tranforms the data from a wide
format (columns of different variables with values in them), to a long format 
(column of variables with a column of values) organized according to a specified
variable.  

```{r plot-same-x-axis-1}

library(reshape2)  #allows us to "melt" dataframes from "wide" to "long"

#merge the two data frames by date and retain all 'harMet.daily
harMetNDVIall.daily.2011<- merge(harMet.daily2011, NDVI.2011, by.x = "date", 
                              by.y = "Date", all.x=TRUE)

#convert from "wide" form to "long" form
harMetNDVI.daily.2011.long<-melt(harMetNDVIall.daily.2011, id ="date")
```

Once we have the data in the long form we can subset and then plot the data. 

``` {r plot-same-x-axis-2}
#subset to retain just the variables of interest.  The vertical bar character
# means "OR".
harMetNDVI.daily.2011.select<-subset(harMetNDVI.daily.2011.long,
                                variable=="meanNDVI"| variable== "prec"|
                                variable == "airt" | variable == "part")

NDVI.harMet.facet.plot<-ggplot(harMetNDVI.daily.2011.select,
                               aes(date, value), group=variable) +
  geom_point() +
  facet_grid(variable~., scales="free") +   #specify facets & y-axis can vary
  ggtitle("Harvard Forest 2011") +
  scale_x_date(labels = date_format("%b %d"),  #abbreviated month & day
               breaks = "3 months", minor_breaks= "1 month") +  #where grid is
  xlab ("Date") + ylab ("Value") +
  theme(legend.position = "none",
        plot.title = element_text(lineheight=.8, face="bold",size = 20),
        text = element_text(size=10)) 

NDVI.harMet.facet.plot

```

